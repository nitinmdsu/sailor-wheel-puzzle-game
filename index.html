<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<title> Sailor wheel puzzle </title>
		<style> 
			* { padding: 0; margin: 0; }
			canvas { background: #eee; display: block; margin: 0 auto; }
		</style> 
	</head>
	<body>
		<p> Just a regular web page, but with a canvas element.</p>
		<canvas id="game" width="640" height="480"> Canvas goes here! </canvas>
		<script>

			var canvas = document.getElementById('game');
			var ctx    = canvas.getContext('2d');

			var centX = canvas.width/2
			var centY = canvas.height/2
			
			prev_state = []
			var rule1 = function(spoke_state, spoke_to_be_updated) { 
				// TODO: change spoke state according to rules
				prev_state = spoke_state; //we need a snap of wheel's previous position to compare with current state so as to recalculate
				//spoke_state[Math.floor((Math.random() * num_spokes) + 1)] = 1 - spoke_state[Math.floor((Math.random() * num_spokes) + 1)];
				curr_spoke_state[spoke_to_be_updated] = 1 - curr_spoke_state[spoke_to_be_updated] //Simple Toggle
 				/*
				
 				update = [[1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1]]
 				for(i = num_spokes; i > 0; --i){
 					if(prev_state[i] != spoke_state[i]){
 						for(j = num_spokes; j > 0; --j{
							if(update[i][j] == 1){
 								spoke_state[j] = 1 - spoke_state[j];
 							}
 							if(update[i][j] == -1{
								//do something else...
 							}
 						}
 					}
 				}

 				*/
 				
				return spoke_state;
				// we could have a matrix. 6x6 matrix in this case.
				// diag elements are 1, and elem [i,j] will be an integer say 1, 0 or -1... 
				//  0 implies ith spoke has no effect on jth. 
				//  1 implies toggle, i.e., modifying ith spoke WILL modify jth irrespective of i's, j's positions. 
				// -1 could imply a conditional toggle like if I push in ith spoke, 
				//    then jth spoke will be pushed in along with it, but pulling i won't affect j. And so on...
			}

			function draw_line(x, y){
				ctx.lineWidth = 600/num_spokes; //thickness
				ctx.strokeStyle = "red";
				ctx.beginPath();
				ctx.moveTo(centX, centY);
				ctx.lineTo(x,y);
				ctx.stroke();
			}

			var draw_spokes = function (spoke_state) {
				for (i = 0; i < num_spokes; i++) {
					r = spoke_state[i] === 1 ? 250 : 180
					k = 30*Math.PI/180
					draw_line(centX + r * Math.cos((Math.PI+i * 2 * Math.PI) / num_spokes ), centY - r * Math.sin((Math.PI+i * 2 * Math.PI) / num_spokes))
				}
			}

			var draw_wheel = function() {
				ctx.fillStyle   = "gold";
				ctx.lineWidth   = 1;
				ctx.beginPath();
				ctx.arc(centX, centY, 120, 0, 2 * Math.PI);
				ctx.closePath();
				ctx.fill();
			}

			function mouse_event (){
				//I click a spoke and the state should toggle like...
				//curr_spoke_state[clickedSpoke] = 1 - curr_spoke_state[clickedSpoke]
			}

			draw_frame = function() { // Grand draw at the end to call everything else
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				draw_spokes(curr_spoke_state);
				draw_wheel();
				// Animation logic etc. goes here, will have to refer back to mdn breakout tutorial
				//console.log(curr_spoke_state)
				curr_spoke_state = rule1(curr_spoke_state);		
			}

			var curr_spoke_state = Array(22).fill(0);
			//var curr_spoke_state = [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0];
			num_spokes = curr_spoke_state.length;
			draw_frame();
			setInterval(draw_frame, 10); //Currently updating every 122 milliseconds, we need to change this to 'update on every mouse click read'
			//mouse_event();

			// So next steps are just to figure out mouse input 
			canvas.onclick = function(e) {

			    // use pageX and pageY to get the mouse position
			    // relative to the browser window

			    var mouse = {
			        m: e.pageX - canvas.offsetLeft,
			        n: e.pageY - canvas.offsetTop
			    }
			    m = mouse.m;
			    n = mouse.n;
			    // console.log(Math.sqrt(Math.pow((m-centX),2)+Math.pow((n-centY),2)))
			    //ctx.arc(centX, centY, 120, 0, 2 * Math.PI);
			    if(Math.sqrt(Math.pow((m-centX),2)+Math.pow((n-centY),2))<170){
			    	angle = Math.atan((centY-n)/(m-centX));
			    	angle = 180*angle/Math.PI;
			    	if((m-centX) < 0){angle = angle + 180}
			    	if((centY-n) < 0 && (m-centX) > 0){angle = angle+360}
			    	spoke_to_be_updated = Math.floor((angle)*num_spokes/360)
			    	console.log(spoke_to_be_updated);
			    	rule1(curr_spoke_state, spoke_to_be_updated)
			    }
			    // now you have local coordinates,
			    // which consider a (0,0) origin at the
			    // top-left of canvas element
			};
		</script>
	</body>
</html>

